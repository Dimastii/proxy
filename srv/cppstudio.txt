SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SELECT version()

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_encoding_to_char(db.encoding) AS serverencoding,
    has_database_privilege(db.oid, 'CREATE') as cancreate, datlastsysoid,
    datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.datname = current_database()

        SELECT
            roles.oid as id, roles.rolname as name,
            roles.rolsuper as is_superuser,
            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
            can_create_role,
            CASE WHEN roles.rolsuper THEN true
            ELSE roles.rolcreatedb END as can_create_db,
            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(
                SELECT pg_catalog.pg_roles.rolname FROM
                pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles ON
                (m.roleid = pg_catalog.pg_roles.oid) WHERE
                 m.member = roles.oid)) THEN True
            ELSE False END as can_signal_backend
        FROM
            pg_catalog.pg_roles as roles
        WHERE
            rolname = current_user
SELECT CASE WHEN usesuper
       THEN pg_catalog.pg_is_in_recovery()
       ELSE FALSE
       END as inrecovery,
       CASE WHEN usesuper AND pg_catalog.pg_is_in_recovery()
       THEN pg_is_wal_replay_paused()
       ELSE FALSE
       END as isreplaypaused
FROM pg_catalog.pg_user WHERE usename=current_user

SELECT
    has_table_privilege(
      'pgagent.pga_job', 'INSERT, SELECT, UPDATE'
    ) has_priviledge
WHERE EXISTS(
    SELECT has_schema_privilege('pgagent', 'USAGE')
    WHERE EXISTS(
        SELECT cl.oid FROM pg_catalog.pg_class cl
        LEFT JOIN pg_catalog.pg_namespace ns ON ns.oid=relnamespace
        WHERE relname='pga_job' AND nspname='pgagent'
    )
)

SELECT
    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner
FROM
    pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
WHERE db.oid > 13441::OID

AND db.datistemplate in (false)

ORDER BY datname;
SELECT
    db.datname AS "Database",     numbackends AS "Backends",
    xact_commit AS "Xact committed",
    xact_rollback AS "Xact rolled back",
    blks_read AS "Blocks read",
    blks_hit AS "Blocks hit",
    tup_returned AS "Tuples returned",
    tup_fetched AS "Tuples fetched",
    tup_inserted AS "Tuples inserted",
    tup_updated AS "Tuples updated",
    tup_deleted AS "Tuples deleted",
    stats_reset AS "Last statistics reset",
    slave.confl_tablespace AS "Tablespace conflicts",
    slave.confl_lock AS "Lock conflicts",
    slave.confl_snapshot AS "Snapshot conflicts",
    slave.confl_bufferpin AS "Bufferpin conflicts",
    slave.confl_deadlock AS "Deadlock conflicts",
    temp_files AS "Temporary files",
    temp_bytes AS "Size of temporary files",
    deadlocks AS "Deadlocks",
    blk_read_time AS "Block read time",
    blk_write_time AS "Block write time",
    pg_catalog.pg_database_size(db.datid) AS "Size"
FROM
    pg_catalog.pg_stat_database db
    LEFT JOIN pg_catalog.pg_stat_database_conflicts slave ON db.datid=slave.datid
WHERE db.datid > 13441::OID

ORDER BY db.datname;
SELECT
	r.oid, r.rolname, r.rolcanlogin, r.rolsuper
FROM
	pg_catalog.pg_roles r
ORDER BY r.rolcanlogin, r.rolname
SELECT
    ts.oid AS oid, spcname AS name, spcowner as owner
FROM
    pg_catalog.pg_tablespace ts
ORDER BY name;
SELECT ts.spcname AS "Name",
    pg_catalog.pg_tablespace_size(ts.oid) AS "Size"
FROM
    pg_catalog.pg_tablespace ts


SELECT
        numbackends AS "Backends",
    xact_commit AS "Xact committed",
    xact_rollback AS "Xact rolled back",
    blks_read AS "Blocks read",
    blks_hit AS "Blocks hit",
    tup_returned AS "Tuples returned",
    tup_fetched AS "Tuples fetched",
    tup_inserted AS "Tuples inserted",
    tup_updated AS "Tuples updated",
    tup_deleted AS "Tuples deleted",
    stats_reset AS "Last statistics reset",
    slave.confl_tablespace AS "Tablespace conflicts",
    slave.confl_lock AS "Lock conflicts",
    slave.confl_snapshot AS "Snapshot conflicts",
    slave.confl_bufferpin AS "Bufferpin conflicts",
    slave.confl_deadlock AS "Deadlock conflicts",
    temp_files AS "Temporary files",
    temp_bytes AS "Size of temporary files",
    deadlocks AS "Deadlocks",
    blk_read_time AS "Block read time",
    blk_write_time AS "Block write time",
    pg_catalog.pg_database_size(db.datid) AS "Size"
FROM
    pg_catalog.pg_stat_database db
    LEFT JOIN pg_catalog.pg_stat_database_conflicts slave ON db.datid=slave.datid
WHERE db.datid = 13442::OID
ORDER BY db.datname;
    SELECT
        ca.oid,
        pg_catalog.concat(pg_catalog.format_type(st.oid,NULL),'->',pg_catalog.format_type(tt.oid,tt.typtypmod)) as name
    FROM pg_catalog.pg_cast ca
    JOIN pg_catalog.pg_type st ON st.oid=castsource
    JOIN pg_catalog.pg_namespace ns ON ns.oid=st.typnamespace
    JOIN pg_catalog.pg_type tt ON tt.oid=casttarget
    JOIN pg_catalog.pg_namespace nt ON nt.oid=tt.typnamespace
    LEFT JOIN pg_catalog.pg_proc pr ON pr.oid=castfunc
    LEFT JOIN pg_catalog.pg_namespace np ON np.oid=pr.pronamespace
    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=ca.oid AND des.objsubid=0 AND des.classoid='pg_cast'::regclass)
                                WHERE
                ca.oid > 13441::OID
        ORDER BY st.typname, tt.typname
SELECT
    nsp.oid,
CASE nsp.nspname
    WHEN 'pg_catalog' THEN 'PostgreSQL Catalog (pg_catalog)'
    WHEN 'pgagent' THEN 'pgAgent Job Scheduler (pgagent)'
    WHEN 'information_schema' THEN 'ANSI (information_schema)'
    ELSE nsp.nspname
    END AS name,
    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage
FROM
    pg_catalog.pg_namespace nsp
WHERE
        (
(nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1))
    )
ORDER BY 2;
SELECT
    nsp.nspname as schema_name,
    (nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1)) AS is_catalog,
    CASE
    WHEN nsp.nspname = ANY('{information_schema}')
        THEN false
    ELSE true END AS db_support
FROM
    pg_catalog.pg_namespace nsp
WHERE
    nsp.oid = 13158::OID;
SELECT
    c.oid, c.relname as name
FROM
    pg_catalog.pg_class c
WHERE relnamespace = 13158::oid
ORDER BY relname;
SELECT
    attnum, attname
FROM pg_catalog.pg_attribute att
WHERE att.attrelid = 13388::oid
  AND att.attnum > 0
  AND att.attisdropped IS FALSE
ORDER BY att.attnum
SELECT
    att.*, def.*, pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
        CASE WHEN att.attndims > 0 THEN 1 ELSE 0 END AS isarray,
        pg_catalog.format_type(ty.oid,NULL) AS typname,
        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
        tn.nspname as typnspname, et.typname as elemtypname,
        ty.typstorage AS defaultstorage, cl.relname, na.nspname,
	att.attstattarget, description, cs.relname AS sername,
	ns.nspname AS serschema,
	(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
	indkey, coll.collname, nspc.nspname as collnspname , attoptions,
	-- Start pgAdmin4, added to save time on client side parsing
	CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
	  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
	ELSE '' END AS collspcname,
	CASE WHEN strpos(pg_catalog.format_type(ty.oid,att.atttypmod), '.') > 0 THEN
	  pg_catalog.split_part(format_type(ty.oid,att.atttypmod), '.', 2)
	ELSE pg_catalog.format_type(ty.oid,att.atttypmod) END AS cltype,
	-- End pgAdmin4
	EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As isfk,
	(SELECT pg_catalog.array_agg(label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS labels,
	(SELECT pg_catalog.array_agg(provider) FROM pg_catalog.pg_seclabels sl2 WHERE sl2.objoid=att.attrelid AND sl2.objsubid=att.attnum) AS providers
FROM pg_catalog.pg_attribute att
  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
  JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
  JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
  JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
  LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
  LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON objid=cs.oid AND classid='pg_class'::regclass AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
  LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
WHERE att.attrelid = 13388::oid  AND att.attnum > 0
  AND att.attisdropped IS FALSE
ORDER BY att.attnum
SELECT
    att.*, def.*, pg_catalog.pg_get_expr(def.adbin, def.adrelid) AS defval,
        CASE WHEN att.attndims > 0 THEN 1 ELSE 0 END AS isarray,
        pg_catalog.format_type(ty.oid,NULL) AS typname,
        pg_catalog.format_type(ty.oid,att.atttypmod) AS displaytypname,
        tn.nspname as typnspname, et.typname as elemtypname,
        ty.typstorage AS defaultstorage, cl.relname, na.nspname,
	att.attstattarget, description, cs.relname AS sername,
	ns.nspname AS serschema,
	(SELECT count(1) FROM pg_catalog.pg_type t2 WHERE t2.typname=ty.typname) > 1 AS isdup,
	indkey, coll.collname, nspc.nspname as collnspname , attoptions,
	-- Start pgAdmin4, added to save time on client side parsing
	CASE WHEN length(coll.collname::text) > 0 AND length(nspc.nspname::text) > 0  THEN
	  pg_catalog.concat(pg_catalog.quote_ident(nspc.nspname),'.',pg_catalog.quote_ident(coll.collname))
	ELSE '' END AS collspcname,
	CASE WHEN strpos(pg_catalog.format_type(ty.oid,att.atttypmod), '.') > 0 THEN
	  pg_catalog.split_part(format_type(ty.oid,att.atttypmod), '.', 2)
	ELSE pg_catalog.format_type(ty.oid,att.atttypmod) END AS cltype,
	-- End pgAdmin4
	EXISTS(SELECT 1 FROM pg_catalog.pg_constraint WHERE conrelid=att.attrelid AND contype='f' AND att.attnum=ANY(conkey)) As isfk,
	(SELECT pg_catalog.array_agg(label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=att.attrelid AND sl1.objsubid=att.attnum) AS labels,
	(SELECT pg_catalog.array_agg(provider) FROM pg_catalog.pg_seclabels sl2 WHERE sl2.objoid=att.attrelid AND sl2.objsubid=att.attnum) AS providers
FROM pg_catalog.pg_attribute att
  JOIN pg_catalog.pg_type ty ON ty.oid=atttypid
  JOIN pg_catalog.pg_namespace tn ON tn.oid=ty.typnamespace
  JOIN pg_catalog.pg_class cl ON cl.oid=att.attrelid
  JOIN pg_catalog.pg_namespace na ON na.oid=cl.relnamespace
  LEFT OUTER JOIN pg_catalog.pg_type et ON et.oid=ty.typelem
  LEFT OUTER JOIN pg_catalog.pg_attrdef def ON adrelid=att.attrelid AND adnum=att.attnum
  LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=att.attrelid AND des.objsubid=att.attnum AND des.classoid='pg_class'::regclass)
  LEFT OUTER JOIN (pg_catalog.pg_depend JOIN pg_catalog.pg_class cs ON objid=cs.oid AND classid='pg_class'::regclass AND cs.relkind='S') ON refobjid=att.attrelid AND refobjsubid=att.attnum
  LEFT OUTER JOIN pg_catalog.pg_namespace ns ON ns.oid=cs.relnamespace
  LEFT OUTER JOIN pg_catalog.pg_index pi ON pi.indrelid=att.attrelid AND indisprimary
  LEFT OUTER JOIN pg_catalog.pg_collation coll ON att.attcollation=coll.oid
  LEFT OUTER JOIN pg_catalog.pg_namespace nspc ON coll.collnamespace=nspc.oid
WHERE att.attrelid = 13388::oid  AND att.attnum > 0
  AND att.attisdropped IS FALSE
ORDER BY att.attnum
SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid > 13441::OID

AND db.datistemplate in (false, False)

ORDER BY datname;
SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SELECT version()

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_encoding_to_char(db.encoding) AS serverencoding,
    has_database_privilege(db.oid, 'CREATE') as cancreate, datlastsysoid,
    datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.datname = current_database()

        SELECT
            roles.oid as id, roles.rolname as name,
            roles.rolsuper as is_superuser,
            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
            can_create_role,
            CASE WHEN roles.rolsuper THEN true
            ELSE roles.rolcreatedb END as can_create_db,
            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(
                SELECT pg_catalog.pg_roles.rolname FROM
                pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles ON
                (m.roleid = pg_catalog.pg_roles.oid) WHERE
                 m.member = roles.oid)) THEN True
            ELSE False END as can_signal_backend
        FROM
            pg_catalog.pg_roles as roles
        WHERE
            rolname = current_user
SELECT CASE WHEN usesuper
       THEN pg_catalog.pg_is_in_recovery()
       ELSE FALSE
       END as inrecovery,
       CASE WHEN usesuper AND pg_catalog.pg_is_in_recovery()
       THEN pg_is_wal_replay_paused()
       ELSE FALSE
       END as isreplaypaused
FROM pg_catalog.pg_user WHERE usename=current_user

SELECT
    has_table_privilege(
      'pgagent.pga_job', 'INSERT, SELECT, UPDATE'
    ) has_priviledge
WHERE EXISTS(
    SELECT has_schema_privilege('pgagent', 'USAGE')
    WHERE EXISTS(
        SELECT cl.oid FROM pg_catalog.pg_class cl
        LEFT JOIN pg_catalog.pg_namespace ns ON ns.oid=relnamespace
        WHERE relname='pga_job' AND nspname='pgagent'
    )
)

SELECT
    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner
FROM
    pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
WHERE db.oid > 13441::OID

AND db.datistemplate in (false)

ORDER BY datname;
SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid > 13441::OID

AND db.datistemplate in (false, False)

ORDER BY datname;

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
    datlastsysoid, datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.oid = 16396
SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid = 13442::OID
AND db.datistemplate in (false, False)

ORDER BY datname;
SELECT version()

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_encoding_to_char(db.encoding) AS serverencoding,
    has_database_privilege(db.oid, 'CREATE') as cancreate, datlastsysoid,
    datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.datname = current_database()

        SELECT
            roles.oid as id, roles.rolname as name,
            roles.rolsuper as is_superuser,
            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
            can_create_role,
            CASE WHEN roles.rolsuper THEN true
            ELSE roles.rolcreatedb END as can_create_db,
            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(
                SELECT pg_catalog.pg_roles.rolname FROM
                pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles ON
                (m.roleid = pg_catalog.pg_roles.oid) WHERE
                 m.member = roles.oid)) THEN True
            ELSE False END as can_signal_backend
        FROM
            pg_catalog.pg_roles as roles
        WHERE
            rolname = current_user
SELECT
    'datacl' AS deftype, COALESCE(gt.rolname, 'PUBLIC') AS grantee,
    g.rolname AS grantor, pg_catalog.array_agg(privilege_type) AS privileges,
    pg_catalog.array_agg(is_grantable) AS grantable
FROM
    (SELECT
        d.grantee, d.grantor, d.is_grantable,
        CASE d.privilege_type
        WHEN 'CONNECT' THEN 'c'
        WHEN 'CREATE' THEN 'C'
        WHEN 'DELETE' THEN 'd'
        WHEN 'EXECUTE' THEN 'X'
        WHEN 'INSERT' THEN 'a'
        WHEN 'REFERENCES' THEN 'x'
        WHEN 'SELECT' THEN 'r'
        WHEN 'TEMPORARY' THEN 'T'
        WHEN 'TRIGGER' THEN 't'
        WHEN 'TRUNCATE' THEN 'D'
        WHEN 'UPDATE' THEN 'w'
        WHEN 'USAGE' THEN 'U'
        ELSE 'UNKNOWN'
        END AS privilege_type
    FROM
        (SELECT
            (d).grantee AS grantee, (d).grantor AS grantor,
            (d).is_grantable AS is_grantable,
            (d).privilege_type AS privilege_type
        FROM
            (SELECT pg_catalog.aclexplode(db.datacl) AS d FROM pg_catalog.pg_database db
            WHERE db.oid = 13442::OID) a
        ) d
    ) d
    LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
    LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
GROUP BY g.rolname, gt.rolname;
SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SELECT version()

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_encoding_to_char(db.encoding) AS serverencoding,
    has_database_privilege(db.oid, 'CREATE') as cancreate, datlastsysoid,
    datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.datname = current_database()

        SELECT
            roles.oid as id, roles.rolname as name,
            roles.rolsuper as is_superuser,
            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
            can_create_role,
            CASE WHEN roles.rolsuper THEN true
            ELSE roles.rolcreatedb END as can_create_db,
            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(
                SELECT pg_catalog.pg_roles.rolname FROM
                pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles ON
                (m.roleid = pg_catalog.pg_roles.oid) WHERE
                 m.member = roles.oid)) THEN True
            ELSE False END as can_signal_backend
        FROM
            pg_catalog.pg_roles as roles
        WHERE
            rolname = current_user
SELECT CASE WHEN usesuper
       THEN pg_catalog.pg_is_in_recovery()
       ELSE FALSE
       END as inrecovery,
       CASE WHEN usesuper AND pg_catalog.pg_is_in_recovery()
       THEN pg_is_wal_replay_paused()
       ELSE FALSE
       END as isreplaypaused
FROM pg_catalog.pg_user WHERE usename=current_user
SELECT CASE WHEN usesuper
       THEN pg_catalog.pg_is_in_recovery()
       ELSE FALSE
       END as inrecovery,
       CASE WHEN usesuper AND pg_catalog.pg_is_in_recovery()
       THEN pg_is_wal_replay_paused()
       ELSE FALSE
       END as isreplaypaused
FROM pg_catalog.pg_user WHERE usename=current_user
SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SELECT version()

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_encoding_to_char(db.encoding) AS serverencoding,
    has_database_privilege(db.oid, 'CREATE') as cancreate, datlastsysoid,
    datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.datname = current_database()

        SELECT
            roles.oid as id, roles.rolname as name,
            roles.rolsuper as is_superuser,
            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
            can_create_role,
            CASE WHEN roles.rolsuper THEN true
            ELSE roles.rolcreatedb END as can_create_db,
            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(
                SELECT pg_catalog.pg_roles.rolname FROM
                pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles ON
                (m.roleid = pg_catalog.pg_roles.oid) WHERE
                 m.member = roles.oid)) THEN True
            ELSE False END as can_signal_backend
        FROM
            pg_catalog.pg_roles as roles
        WHERE
            rolname = current_user

SELECT
    has_table_privilege(
      'pgagent.pga_job', 'INSERT, SELECT, UPDATE'
    ) has_priviledge
WHERE EXISTS(
    SELECT has_schema_privilege('pgagent', 'USAGE')
    WHERE EXISTS(
        SELECT cl.oid FROM pg_catalog.pg_class cl
        LEFT JOIN pg_catalog.pg_namespace ns ON ns.oid=relnamespace
        WHERE relname='pga_job' AND nspname='pgagent'
    )
)

SELECT
    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner
FROM
    pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
WHERE db.oid > 13441::OID

AND db.datistemplate in (false)

ORDER BY datname;
SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SELECT version()

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_encoding_to_char(db.encoding) AS serverencoding,
    has_database_privilege(db.oid, 'CREATE') as cancreate, datlastsysoid,
    datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.datname = current_database()

        SELECT
            roles.oid as id, roles.rolname as name,
            roles.rolsuper as is_superuser,
            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
            can_create_role,
            CASE WHEN roles.rolsuper THEN true
            ELSE roles.rolcreatedb END as can_create_db,
            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(
                SELECT pg_catalog.pg_roles.rolname FROM
                pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles ON
                (m.roleid = pg_catalog.pg_roles.oid) WHERE
                 m.member = roles.oid)) THEN True
            ELSE False END as can_signal_backend
        FROM
            pg_catalog.pg_roles as roles
        WHERE
            rolname = current_user
SELECT CASE WHEN usesuper
       THEN pg_catalog.pg_is_in_recovery()
       ELSE FALSE
       END as inrecovery,
       CASE WHEN usesuper AND pg_catalog.pg_is_in_recovery()
       THEN pg_is_wal_replay_paused()
       ELSE FALSE
       END as isreplaypaused
FROM pg_catalog.pg_user WHERE usename=current_user

SELECT
    has_table_privilege(
      'pgagent.pga_job', 'INSERT, SELECT, UPDATE'
    ) has_priviledge
WHERE EXISTS(
    SELECT has_schema_privilege('pgagent', 'USAGE')
    WHERE EXISTS(
        SELECT cl.oid FROM pg_catalog.pg_class cl
        LEFT JOIN pg_catalog.pg_namespace ns ON ns.oid=relnamespace
        WHERE relname='pga_job' AND nspname='pgagent'
    )
)

SELECT
    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner
FROM
    pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
WHERE db.oid > 13441::OID

AND db.datistemplate in (false)

ORDER BY datname;
SELECT
    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner
FROM
    pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
WHERE db.oid > 13441::OID

AND db.datistemplate in (false)

ORDER BY datname;
SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid > 13441::OID

AND db.datistemplate in (false, False)

ORDER BY datname;

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
    datlastsysoid, datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.oid = 16396
SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid = 13442::OID
AND db.datistemplate in (false, False)

ORDER BY datname;
SELECT
    'datacl' AS deftype, COALESCE(gt.rolname, 'PUBLIC') AS grantee,
    g.rolname AS grantor, pg_catalog.array_agg(privilege_type) AS privileges,
    pg_catalog.array_agg(is_grantable) AS grantable
FROM
    (SELECT
        d.grantee, d.grantor, d.is_grantable,
        CASE d.privilege_type
        WHEN 'CONNECT' THEN 'c'
        WHEN 'CREATE' THEN 'C'
        WHEN 'DELETE' THEN 'd'
        WHEN 'EXECUTE' THEN 'X'
        WHEN 'INSERT' THEN 'a'
        WHEN 'REFERENCES' THEN 'x'
        WHEN 'SELECT' THEN 'r'
        WHEN 'TEMPORARY' THEN 'T'
        WHEN 'TRIGGER' THEN 't'
        WHEN 'TRUNCATE' THEN 'D'
        WHEN 'UPDATE' THEN 'w'
        WHEN 'USAGE' THEN 'U'
        ELSE 'UNKNOWN'
        END AS privilege_type
    FROM
        (SELECT
            (d).grantee AS grantee, (d).grantor AS grantor,
            (d).is_grantable AS is_grantable,
            (d).privilege_type AS privilege_type
        FROM
            (SELECT pg_catalog.aclexplode(db.datacl) AS d FROM pg_catalog.pg_database db
            WHERE db.oid = 13442::OID) a
        ) d
    ) d
    LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
    LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
GROUP BY g.rolname, gt.rolname;
SELECT
    CASE (a.deftype)
    WHEN 'r' THEN 'deftblacl'
    WHEN 'S' THEN 'defseqacl'
    WHEN 'f' THEN 'deffuncacl'
    WHEN 'T' THEN 'deftypeacl'
    END AS deftype,
    COALESCE(gt.rolname, 'PUBLIC') AS grantee, g.rolname AS grantor, pg_catalog.array_agg(a.privilege_type) as privileges, pg_catalog.array_agg(a.is_grantable) as grantable
FROM
    (SELECT
        (acl).grantee as grantee, (acl).grantor AS grantor, (acl).is_grantable AS is_grantable,
        CASE (acl).privilege_type
        WHEN 'CONNECT' THEN 'c'
        WHEN 'CREATE' THEN 'C'
        WHEN 'DELETE' THEN 'd'
        WHEN 'EXECUTE' THEN 'X'
        WHEN 'INSERT' THEN 'a'
        WHEN 'REFERENCES' THEN 'x'
        WHEN 'SELECT' THEN 'r'
        WHEN 'TEMPORARY' THEN 'T'
        WHEN 'TRIGGER' THEN 't'
        WHEN 'TRUNCATE' THEN 'D'
        WHEN 'UPDATE' THEN 'w'
        WHEN 'USAGE' THEN 'U'
        ELSE 'UNKNOWN'
        END AS privilege_type,
        defaclobjtype as deftype
    FROM
        (SELECT defaclobjtype, pg_catalog.aclexplode(defaclacl) as acl FROM pg_catalog.pg_default_acl dacl
      WHERE dacl.defaclnamespace = 0::OID) d) a
    LEFT JOIN pg_catalog.pg_roles g ON (a.grantor = g.oid)
    LEFT JOIN pg_catalog.pg_roles gt ON (a.grantee = gt.oid)
GROUP BY g.rolname, gt.rolname, a.deftype
ORDER BY a.deftype
SELECT
    rl.*, r.rolname AS user_name, db.datname as db_name
FROM pg_catalog.pg_db_role_setting AS rl
    LEFT JOIN pg_catalog.pg_roles AS r ON rl.setrole = r.oid
    LEFT JOIN pg_catalog.pg_database AS db ON rl.setdatabase = db.oid
WHERE setdatabase = 13442
SELECT
	r.oid, r.rolname, r.rolcanlogin, r.rolsuper
FROM
	pg_catalog.pg_roles r
ORDER BY r.rolcanlogin, r.rolname
SELECT *
FROM
    (SELECT pg_catalog.pg_encoding_to_char(s.i) AS encoding
    FROM (SELECT pg_catalog.generate_series(0, 100, 1) as i) s) a
WHERE encoding != '' ORDER BY encoding



SELECT
    ts.oid AS oid, spcname AS name, spcowner as owner
FROM
    pg_catalog.pg_tablespace ts
ORDER BY name;
SELECT DISTINCT(datctype) AS cname
FROM pg_catalog.pg_database
UNION
SELECT DISTINCT(datcollate) AS cname
FROM pg_catalog.pg_database
SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SELECT version()

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_encoding_to_char(db.encoding) AS serverencoding,
    has_database_privilege(db.oid, 'CREATE') as cancreate, datlastsysoid,
    datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.datname = current_database()

        SELECT
            roles.oid as id, roles.rolname as name,
            roles.rolsuper as is_superuser,
            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
            can_create_role,
            CASE WHEN roles.rolsuper THEN true
            ELSE roles.rolcreatedb END as can_create_db,
            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(
                SELECT pg_catalog.pg_roles.rolname FROM
                pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles ON
                (m.roleid = pg_catalog.pg_roles.oid) WHERE
                 m.member = roles.oid)) THEN True
            ELSE False END as can_signal_backend
        FROM
            pg_catalog.pg_roles as roles
        WHERE
            rolname = current_user
SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid = 16396::OID
AND db.datistemplate in (false, False)

ORDER BY datname;
SELECT version()
SELECT
    'datacl' AS deftype, COALESCE(gt.rolname, 'PUBLIC') AS grantee,
    g.rolname AS grantor, pg_catalog.array_agg(privilege_type) AS privileges,
    pg_catalog.array_agg(is_grantable) AS grantable
FROM
    (SELECT
        d.grantee, d.grantor, d.is_grantable,
        CASE d.privilege_type
        WHEN 'CONNECT' THEN 'c'
        WHEN 'CREATE' THEN 'C'
        WHEN 'DELETE' THEN 'd'
        WHEN 'EXECUTE' THEN 'X'
        WHEN 'INSERT' THEN 'a'
        WHEN 'REFERENCES' THEN 'x'
        WHEN 'SELECT' THEN 'r'
        WHEN 'TEMPORARY' THEN 'T'
        WHEN 'TRIGGER' THEN 't'
        WHEN 'TRUNCATE' THEN 'D'
        WHEN 'UPDATE' THEN 'w'
        WHEN 'USAGE' THEN 'U'
        ELSE 'UNKNOWN'
        END AS privilege_type
    FROM
        (SELECT
            (d).grantee AS grantee, (d).grantor AS grantor,
            (d).is_grantable AS is_grantable,
            (d).privilege_type AS privilege_type
        FROM
            (SELECT pg_catalog.aclexplode(db.datacl) AS d FROM pg_catalog.pg_database db
            WHERE db.oid = 16396::OID) a
        ) d
    ) d
    LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
    LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
GROUP BY g.rolname, gt.rolname;

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_encoding_to_char(db.encoding) AS serverencoding,
    has_database_privilege(db.oid, 'CREATE') as cancreate, datlastsysoid,
    datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.datname = current_database()
SELECT
    CASE (a.deftype)
    WHEN 'r' THEN 'deftblacl'
    WHEN 'S' THEN 'defseqacl'
    WHEN 'f' THEN 'deffuncacl'
    WHEN 'T' THEN 'deftypeacl'
    END AS deftype,
    COALESCE(gt.rolname, 'PUBLIC') AS grantee, g.rolname AS grantor, pg_catalog.array_agg(a.privilege_type) as privileges, pg_catalog.array_agg(a.is_grantable) as grantable
FROM
    (SELECT
        (acl).grantee as grantee, (acl).grantor AS grantor, (acl).is_grantable AS is_grantable,
        CASE (acl).privilege_type
        WHEN 'CONNECT' THEN 'c'
        WHEN 'CREATE' THEN 'C'
        WHEN 'DELETE' THEN 'd'
        WHEN 'EXECUTE' THEN 'X'
        WHEN 'INSERT' THEN 'a'
        WHEN 'REFERENCES' THEN 'x'
        WHEN 'SELECT' THEN 'r'
        WHEN 'TEMPORARY' THEN 'T'
        WHEN 'TRIGGER' THEN 't'
        WHEN 'TRUNCATE' THEN 'D'
        WHEN 'UPDATE' THEN 'w'
        WHEN 'USAGE' THEN 'U'
        ELSE 'UNKNOWN'
        END AS privilege_type,
        defaclobjtype as deftype
    FROM
        (SELECT defaclobjtype, pg_catalog.aclexplode(defaclacl) as acl FROM pg_catalog.pg_default_acl dacl
      WHERE dacl.defaclnamespace = 0::OID) d) a
    LEFT JOIN pg_catalog.pg_roles g ON (a.grantor = g.oid)
    LEFT JOIN pg_catalog.pg_roles gt ON (a.grantee = gt.oid)
GROUP BY g.rolname, gt.rolname, a.deftype
ORDER BY a.deftype

        SELECT
            roles.oid as id, roles.rolname as name,
            roles.rolsuper as is_superuser,
            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
            can_create_role,
            CASE WHEN roles.rolsuper THEN true
            ELSE roles.rolcreatedb END as can_create_db,
            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(
                SELECT pg_catalog.pg_roles.rolname FROM
                pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles ON
                (m.roleid = pg_catalog.pg_roles.oid) WHERE
                 m.member = roles.oid)) THEN True
            ELSE False END as can_signal_backend
        FROM
            pg_catalog.pg_roles as roles
        WHERE
            rolname = current_user
SELECT
    rl.*, r.rolname AS user_name, db.datname as db_name
FROM pg_catalog.pg_db_role_setting AS rl
    LEFT JOIN pg_catalog.pg_roles AS r ON rl.setrole = r.oid
    LEFT JOIN pg_catalog.pg_database AS db ON rl.setdatabase = db.oid
WHERE setdatabase = 16396
SELECT
    2 AS nsptyp,
    nsp.nspname AS name,
    nsp.oid,
    pg_catalog.array_to_string(nsp.nspacl::text[], ', ') as acl,
    r.rolname AS namespaceowner, description,
    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') AS can_create,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'r' AND defaclnamespace = nsp.oid) AS tblacl,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'S' AND defaclnamespace = nsp.oid) AS seqacl,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'f' AND defaclnamespace = nsp.oid) AS funcacl,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'T' AND defaclnamespace = nsp.oid) AS typeacl
FROM
    pg_catalog.pg_namespace nsp
    LEFT OUTER JOIN pg_catalog.pg_description des ON
        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
    LEFT JOIN pg_catalog.pg_roles r ON (r.oid = nsp.nspowner)
WHERE
        (
(nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1))
    )
ORDER BY 1, nspname;
SELECT e.oid, e.xmin, e.evtname AS name, upper(e.evtevent) AS eventname,
pg_catalog.pg_get_userbyid(e.evtowner) AS eventowner,
e.evtenabled AS enabled,
e.evtfoid AS eventfuncoid,
CASE
  WHEN n.nspname = 'public'
  THEN pg_catalog.quote_ident(n.nspname) || '.' || cast(e.evtfoid::regproc as text)
  ELSE cast(e.evtfoid::regproc as text)
END AS  eventfunname,
pg_catalog.array_to_string(array(select pg_catalog.quote_literal(x) from pg_catalog.unnest(evttags) as t(x)), ', ') AS when,
 pg_catalog.obj_description(e.oid, 'pg_event_trigger') AS comment,
 (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabel sl1 WHERE sl1.objoid=e.oid) AS seclabels,
 p.prosrc AS source, p.pronamespace AS schemaoid, l.lanname AS language
 FROM pg_catalog.pg_event_trigger e
 LEFT OUTER JOIN pg_catalog.pg_proc p ON p.oid=e.evtfoid
 LEFT OUTER JOIN pg_catalog.pg_language l ON l.oid=p.prolang,
 pg_catalog.pg_namespace n
 WHERE p.pronamespace = n.oid
  ORDER BY e.evtname
SELECT
    x.oid, pg_catalog.pg_get_userbyid(extowner) AS owner,
    x.extname AS name, n.nspname AS schema,
    x.extrelocatable AS relocatable, x.extversion AS version,
    e.comment
FROM
    pg_catalog.pg_extension x
    LEFT JOIN pg_catalog.pg_namespace n ON x.extnamespace=n.oid
    JOIN pg_catalog.pg_available_extensions() e(name, default_version, comment) ON x.extname=e.name ORDER BY x.extname

SELECT fdw.oid, fdwname as name, fdwhandler, fdwvalidator, description,
    fdwoptions AS fdwoptions, pg_catalog.pg_get_userbyid(fdwowner) as fdwowner, pg_catalog.array_to_string(fdwacl::text[], ', ') as acl,
    CASE
    -- EPAS in redwood mode, concatenation of a string with NULL results as the original string
    WHEN vp.proname IS NULL THEN NULL
    ELSE pg_catalog.quote_ident(vp_nsp.nspname)||'.'||pg_catalog.quote_ident(vp.proname)
    END fdwvalue,
    CASE
    -- EPAS in redwood mode, concatenation of a string with NULL results as the original string
    WHEN vh.proname IS NULL THEN NULL
    ELSE pg_catalog.quote_ident(vh_nsp.nspname)||'.'||pg_catalog.quote_ident(vh.proname)
    END fdwhan
FROM pg_catalog.pg_foreign_data_wrapper fdw
    LEFT OUTER JOIN pg_catalog.pg_proc vh on vh.oid=fdwhandler
    LEFT OUTER JOIN pg_catalog.pg_proc vp on vp.oid=fdwvalidator
    LEFT OUTER JOIN pg_catalog.pg_namespace vh_nsp ON vh_nsp.oid=vh.pronamespace
    LEFT OUTER JOIN pg_catalog.pg_namespace vp_nsp ON vp_nsp.oid=vp.pronamespace
    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=fdw.oid AND des.objsubid=0 AND des.classoid='pg_foreign_data_wrapper'::regclass)
ORDER BY fdwname
SELECT
    x.oid, pg_catalog.pg_get_userbyid(extowner) AS owner,
    x.extname AS name, n.nspname AS schema,
    x.extrelocatable AS relocatable, x.extversion AS version,
    e.comment
FROM
    pg_catalog.pg_extension x
    LEFT JOIN pg_catalog.pg_namespace n ON x.extnamespace=n.oid
    JOIN pg_catalog.pg_available_extensions() e(name, default_version, comment) ON x.extname=e.name ORDER BY x.extname

SELECT
    x.oid, pg_catalog.pg_get_userbyid(extowner) AS owner,
    x.extname AS name, n.nspname AS schema,
    x.extrelocatable AS relocatable, x.extversion AS version,
    e.comment
FROM
    pg_catalog.pg_extension x
    LEFT JOIN pg_catalog.pg_namespace n ON x.extnamespace=n.oid
    JOIN pg_catalog.pg_available_extensions() e(name, default_version, comment) ON x.extname=e.name ORDER BY x.extname

SELECT
    2 AS nsptyp,
    nsp.nspname AS name,
    nsp.oid,
    pg_catalog.array_to_string(nsp.nspacl::text[], ', ') as acl,
    r.rolname AS namespaceowner, description,
    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') AS can_create,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'r' AND defaclnamespace = nsp.oid) AS tblacl,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'S' AND defaclnamespace = nsp.oid) AS seqacl,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'f' AND defaclnamespace = nsp.oid) AS funcacl,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'T' AND defaclnamespace = nsp.oid) AS typeacl
FROM
    pg_catalog.pg_namespace nsp
    LEFT OUTER JOIN pg_catalog.pg_description des ON
        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
    LEFT JOIN pg_catalog.pg_roles r ON (r.oid = nsp.nspowner)
WHERE
        (
(nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1))
    )
ORDER BY 1, nspname;
SELECT
    nsp.oid,
CASE nsp.nspname
    WHEN 'pg_catalog' THEN 'PostgreSQL Catalog (pg_catalog)'
    WHEN 'pgagent' THEN 'pgAgent Job Scheduler (pgagent)'
    WHEN 'information_schema' THEN 'ANSI (information_schema)'
    ELSE nsp.nspname
    END AS name,
    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage
FROM
    pg_catalog.pg_namespace nsp
WHERE
        (
(nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1))
    )
ORDER BY 2;
SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SELECT version()

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_encoding_to_char(db.encoding) AS serverencoding,
    has_database_privilege(db.oid, 'CREATE') as cancreate, datlastsysoid,
    datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.datname = current_database()

        SELECT
            roles.oid as id, roles.rolname as name,
            roles.rolsuper as is_superuser,
            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
            can_create_role,
            CASE WHEN roles.rolsuper THEN true
            ELSE roles.rolcreatedb END as can_create_db,
            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(
                SELECT pg_catalog.pg_roles.rolname FROM
                pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles ON
                (m.roleid = pg_catalog.pg_roles.oid) WHERE
                 m.member = roles.oid)) THEN True
            ELSE False END as can_signal_backend
        FROM
            pg_catalog.pg_roles as roles
        WHERE
            rolname = current_user
SELECT CASE WHEN usesuper
       THEN pg_catalog.pg_is_in_recovery()
       ELSE FALSE
       END as inrecovery,
       CASE WHEN usesuper AND pg_catalog.pg_is_in_recovery()
       THEN pg_is_wal_replay_paused()
       ELSE FALSE
       END as isreplaypaused
FROM pg_catalog.pg_user WHERE usename=current_user

SELECT
    has_table_privilege(
      'pgagent.pga_job', 'INSERT, SELECT, UPDATE'
    ) has_priviledge
WHERE EXISTS(
    SELECT has_schema_privilege('pgagent', 'USAGE')
    WHERE EXISTS(
        SELECT cl.oid FROM pg_catalog.pg_class cl
        LEFT JOIN pg_catalog.pg_namespace ns ON ns.oid=relnamespace
        WHERE relname='pga_job' AND nspname='pgagent'
    )
)

SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid > 13441::OID

AND db.datistemplate in (false, False)

ORDER BY datname;
SELECT
    db.oid as did, db.datname as name, ta.spcname as spcname, db.datallowconn,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate, datdba as owner
FROM
    pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace = ta.oid
WHERE db.oid > 13441::OID

AND db.datistemplate in (false)

ORDER BY datname;

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_catalog.pg_encoding_to_char(db.encoding) AS serverencoding,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') as cancreate,
    datlastsysoid, datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.oid = 16396
SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid = 13442::OID
AND db.datistemplate in (false, False)

ORDER BY datname;
SELECT
    'datacl' AS deftype, COALESCE(gt.rolname, 'PUBLIC') AS grantee,
    g.rolname AS grantor, pg_catalog.array_agg(privilege_type) AS privileges,
    pg_catalog.array_agg(is_grantable) AS grantable
FROM
    (SELECT
        d.grantee, d.grantor, d.is_grantable,
        CASE d.privilege_type
        WHEN 'CONNECT' THEN 'c'
        WHEN 'CREATE' THEN 'C'
        WHEN 'DELETE' THEN 'd'
        WHEN 'EXECUTE' THEN 'X'
        WHEN 'INSERT' THEN 'a'
        WHEN 'REFERENCES' THEN 'x'
        WHEN 'SELECT' THEN 'r'
        WHEN 'TEMPORARY' THEN 'T'
        WHEN 'TRIGGER' THEN 't'
        WHEN 'TRUNCATE' THEN 'D'
        WHEN 'UPDATE' THEN 'w'
        WHEN 'USAGE' THEN 'U'
        ELSE 'UNKNOWN'
        END AS privilege_type
    FROM
        (SELECT
            (d).grantee AS grantee, (d).grantor AS grantor,
            (d).is_grantable AS is_grantable,
            (d).privilege_type AS privilege_type
        FROM
            (SELECT pg_catalog.aclexplode(db.datacl) AS d FROM pg_catalog.pg_database db
            WHERE db.oid = 13442::OID) a
        ) d
    ) d
    LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
    LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
GROUP BY g.rolname, gt.rolname;
SELECT
    CASE (a.deftype)
    WHEN 'r' THEN 'deftblacl'
    WHEN 'S' THEN 'defseqacl'
    WHEN 'f' THEN 'deffuncacl'
    WHEN 'T' THEN 'deftypeacl'
    END AS deftype,
    COALESCE(gt.rolname, 'PUBLIC') AS grantee, g.rolname AS grantor, pg_catalog.array_agg(a.privilege_type) as privileges, pg_catalog.array_agg(a.is_grantable) as grantable
FROM
    (SELECT
        (acl).grantee as grantee, (acl).grantor AS grantor, (acl).is_grantable AS is_grantable,
        CASE (acl).privilege_type
        WHEN 'CONNECT' THEN 'c'
        WHEN 'CREATE' THEN 'C'
        WHEN 'DELETE' THEN 'd'
        WHEN 'EXECUTE' THEN 'X'
        WHEN 'INSERT' THEN 'a'
        WHEN 'REFERENCES' THEN 'x'
        WHEN 'SELECT' THEN 'r'
        WHEN 'TEMPORARY' THEN 'T'
        WHEN 'TRIGGER' THEN 't'
        WHEN 'TRUNCATE' THEN 'D'
        WHEN 'UPDATE' THEN 'w'
        WHEN 'USAGE' THEN 'U'
        ELSE 'UNKNOWN'
        END AS privilege_type,
        defaclobjtype as deftype
    FROM
        (SELECT defaclobjtype, pg_catalog.aclexplode(defaclacl) as acl FROM pg_catalog.pg_default_acl dacl
      WHERE dacl.defaclnamespace = 0::OID) d) a
    LEFT JOIN pg_catalog.pg_roles g ON (a.grantor = g.oid)
    LEFT JOIN pg_catalog.pg_roles gt ON (a.grantee = gt.oid)
GROUP BY g.rolname, gt.rolname, a.deftype
ORDER BY a.deftype
SELECT
    rl.*, r.rolname AS user_name, db.datname as db_name
FROM pg_catalog.pg_db_role_setting AS rl
    LEFT JOIN pg_catalog.pg_roles AS r ON rl.setrole = r.oid
    LEFT JOIN pg_catalog.pg_database AS db ON rl.setdatabase = db.oid
WHERE setdatabase = 13442
SELECT
	r.oid, r.rolname, r.rolcanlogin, r.rolsuper
FROM
	pg_catalog.pg_roles r
ORDER BY r.rolcanlogin, r.rolname
SELECT *
FROM
    (SELECT pg_catalog.pg_encoding_to_char(s.i) AS encoding
    FROM (SELECT pg_catalog.generate_series(0, 100, 1) as i) s) a
WHERE encoding != '' ORDER BY encoding



SELECT
    ts.oid AS oid, spcname AS name, spcowner as owner
FROM
    pg_catalog.pg_tablespace ts
ORDER BY name;
SELECT DISTINCT(datctype) AS cname
FROM pg_catalog.pg_database
UNION
SELECT DISTINCT(datcollate) AS cname
FROM pg_catalog.pg_database
SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SELECT version()

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_encoding_to_char(db.encoding) AS serverencoding,
    has_database_privilege(db.oid, 'CREATE') as cancreate, datlastsysoid,
    datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.datname = current_database()

        SELECT
            roles.oid as id, roles.rolname as name,
            roles.rolsuper as is_superuser,
            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
            can_create_role,
            CASE WHEN roles.rolsuper THEN true
            ELSE roles.rolcreatedb END as can_create_db,
            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(
                SELECT pg_catalog.pg_roles.rolname FROM
                pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles ON
                (m.roleid = pg_catalog.pg_roles.oid) WHERE
                 m.member = roles.oid)) THEN True
            ELSE False END as can_signal_backend
        FROM
            pg_catalog.pg_roles as roles
        WHERE
            rolname = current_user
SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid = 16396::OID
AND db.datistemplate in (false, False)

ORDER BY datname;
SELECT version()
SELECT
    'datacl' AS deftype, COALESCE(gt.rolname, 'PUBLIC') AS grantee,
    g.rolname AS grantor, pg_catalog.array_agg(privilege_type) AS privileges,
    pg_catalog.array_agg(is_grantable) AS grantable
FROM
    (SELECT
        d.grantee, d.grantor, d.is_grantable,
        CASE d.privilege_type
        WHEN 'CONNECT' THEN 'c'
        WHEN 'CREATE' THEN 'C'
        WHEN 'DELETE' THEN 'd'
        WHEN 'EXECUTE' THEN 'X'
        WHEN 'INSERT' THEN 'a'
        WHEN 'REFERENCES' THEN 'x'
        WHEN 'SELECT' THEN 'r'
        WHEN 'TEMPORARY' THEN 'T'
        WHEN 'TRIGGER' THEN 't'
        WHEN 'TRUNCATE' THEN 'D'
        WHEN 'UPDATE' THEN 'w'
        WHEN 'USAGE' THEN 'U'
        ELSE 'UNKNOWN'
        END AS privilege_type
    FROM
        (SELECT
            (d).grantee AS grantee, (d).grantor AS grantor,
            (d).is_grantable AS is_grantable,
            (d).privilege_type AS privilege_type
        FROM
            (SELECT pg_catalog.aclexplode(db.datacl) AS d FROM pg_catalog.pg_database db
            WHERE db.oid = 16396::OID) a
        ) d
    ) d
    LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
    LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
GROUP BY g.rolname, gt.rolname;

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_encoding_to_char(db.encoding) AS serverencoding,
    has_database_privilege(db.oid, 'CREATE') as cancreate, datlastsysoid,
    datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.datname = current_database()
SELECT
    CASE (a.deftype)
    WHEN 'r' THEN 'deftblacl'
    WHEN 'S' THEN 'defseqacl'
    WHEN 'f' THEN 'deffuncacl'
    WHEN 'T' THEN 'deftypeacl'
    END AS deftype,
    COALESCE(gt.rolname, 'PUBLIC') AS grantee, g.rolname AS grantor, pg_catalog.array_agg(a.privilege_type) as privileges, pg_catalog.array_agg(a.is_grantable) as grantable
FROM
    (SELECT
        (acl).grantee as grantee, (acl).grantor AS grantor, (acl).is_grantable AS is_grantable,
        CASE (acl).privilege_type
        WHEN 'CONNECT' THEN 'c'
        WHEN 'CREATE' THEN 'C'
        WHEN 'DELETE' THEN 'd'
        WHEN 'EXECUTE' THEN 'X'
        WHEN 'INSERT' THEN 'a'
        WHEN 'REFERENCES' THEN 'x'
        WHEN 'SELECT' THEN 'r'
        WHEN 'TEMPORARY' THEN 'T'
        WHEN 'TRIGGER' THEN 't'
        WHEN 'TRUNCATE' THEN 'D'
        WHEN 'UPDATE' THEN 'w'
        WHEN 'USAGE' THEN 'U'
        ELSE 'UNKNOWN'
        END AS privilege_type,
        defaclobjtype as deftype
    FROM
        (SELECT defaclobjtype, pg_catalog.aclexplode(defaclacl) as acl FROM pg_catalog.pg_default_acl dacl
      WHERE dacl.defaclnamespace = 0::OID) d) a
    LEFT JOIN pg_catalog.pg_roles g ON (a.grantor = g.oid)
    LEFT JOIN pg_catalog.pg_roles gt ON (a.grantee = gt.oid)
GROUP BY g.rolname, gt.rolname, a.deftype
ORDER BY a.deftype

        SELECT
            roles.oid as id, roles.rolname as name,
            roles.rolsuper as is_superuser,
            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
            can_create_role,
            CASE WHEN roles.rolsuper THEN true
            ELSE roles.rolcreatedb END as can_create_db,
            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(
                SELECT pg_catalog.pg_roles.rolname FROM
                pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles ON
                (m.roleid = pg_catalog.pg_roles.oid) WHERE
                 m.member = roles.oid)) THEN True
            ELSE False END as can_signal_backend
        FROM
            pg_catalog.pg_roles as roles
        WHERE
            rolname = current_user
SELECT
    rl.*, r.rolname AS user_name, db.datname as db_name
FROM pg_catalog.pg_db_role_setting AS rl
    LEFT JOIN pg_catalog.pg_roles AS r ON rl.setrole = r.oid
    LEFT JOIN pg_catalog.pg_database AS db ON rl.setdatabase = db.oid
WHERE setdatabase = 16396
SELECT
    2 AS nsptyp,
    nsp.nspname AS name,
    nsp.oid,
    pg_catalog.array_to_string(nsp.nspacl::text[], ', ') as acl,
    r.rolname AS namespaceowner, description,
    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') AS can_create,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'r' AND defaclnamespace = nsp.oid) AS tblacl,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'S' AND defaclnamespace = nsp.oid) AS seqacl,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'f' AND defaclnamespace = nsp.oid) AS funcacl,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'T' AND defaclnamespace = nsp.oid) AS typeacl
FROM
    pg_catalog.pg_namespace nsp
    LEFT OUTER JOIN pg_catalog.pg_description des ON
        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
    LEFT JOIN pg_catalog.pg_roles r ON (r.oid = nsp.nspowner)
WHERE
        (
(nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1))
    )
ORDER BY 1, nspname;
SELECT
    nsp.oid,
CASE nsp.nspname
    WHEN 'pg_catalog' THEN 'PostgreSQL Catalog (pg_catalog)'
    WHEN 'pgagent' THEN 'pgAgent Job Scheduler (pgagent)'
    WHEN 'information_schema' THEN 'ANSI (information_schema)'
    ELSE nsp.nspname
    END AS name,
    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage
FROM
    pg_catalog.pg_namespace nsp
WHERE
        (
(nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1))
    )
ORDER BY 2;
SELECT
    x.oid, pg_catalog.pg_get_userbyid(extowner) AS owner,
    x.extname AS name, n.nspname AS schema,
    x.extrelocatable AS relocatable, x.extversion AS version,
    e.comment
FROM
    pg_catalog.pg_extension x
    LEFT JOIN pg_catalog.pg_namespace n ON x.extnamespace=n.oid
    JOIN pg_catalog.pg_available_extensions() e(name, default_version, comment) ON x.extname=e.name ORDER BY x.extname

SELECT
    x.oid, pg_catalog.pg_get_userbyid(extowner) AS owner,
    x.extname AS name, n.nspname AS schema,
    x.extrelocatable AS relocatable, x.extversion AS version,
    e.comment
FROM
    pg_catalog.pg_extension x
    LEFT JOIN pg_catalog.pg_namespace n ON x.extnamespace=n.oid
    JOIN pg_catalog.pg_available_extensions() e(name, default_version, comment) ON x.extname=e.name ORDER BY x.extname

SELECT fdw.oid, fdwname as name, fdwhandler, fdwvalidator, description,
    fdwoptions AS fdwoptions, pg_catalog.pg_get_userbyid(fdwowner) as fdwowner, pg_catalog.array_to_string(fdwacl::text[], ', ') as acl,
    CASE
    -- EPAS in redwood mode, concatenation of a string with NULL results as the original string
    WHEN vp.proname IS NULL THEN NULL
    ELSE pg_catalog.quote_ident(vp_nsp.nspname)||'.'||pg_catalog.quote_ident(vp.proname)
    END fdwvalue,
    CASE
    -- EPAS in redwood mode, concatenation of a string with NULL results as the original string
    WHEN vh.proname IS NULL THEN NULL
    ELSE pg_catalog.quote_ident(vh_nsp.nspname)||'.'||pg_catalog.quote_ident(vh.proname)
    END fdwhan
FROM pg_catalog.pg_foreign_data_wrapper fdw
    LEFT OUTER JOIN pg_catalog.pg_proc vh on vh.oid=fdwhandler
    LEFT OUTER JOIN pg_catalog.pg_proc vp on vp.oid=fdwvalidator
    LEFT OUTER JOIN pg_catalog.pg_namespace vh_nsp ON vh_nsp.oid=vh.pronamespace
    LEFT OUTER JOIN pg_catalog.pg_namespace vp_nsp ON vp_nsp.oid=vp.pronamespace
    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=fdw.oid AND des.objsubid=0 AND des.classoid='pg_foreign_data_wrapper'::regclass)
ORDER BY fdwname
SELECT fdw.oid, fdwname as name, fdwhandler, fdwvalidator, description,
    fdwoptions AS fdwoptions, pg_catalog.pg_get_userbyid(fdwowner) as fdwowner, pg_catalog.array_to_string(fdwacl::text[], ', ') as acl,
    CASE
    -- EPAS in redwood mode, concatenation of a string with NULL results as the original string
    WHEN vp.proname IS NULL THEN NULL
    ELSE pg_catalog.quote_ident(vp_nsp.nspname)||'.'||pg_catalog.quote_ident(vp.proname)
    END fdwvalue,
    CASE
    -- EPAS in redwood mode, concatenation of a string with NULL results as the original string
    WHEN vh.proname IS NULL THEN NULL
    ELSE pg_catalog.quote_ident(vh_nsp.nspname)||'.'||pg_catalog.quote_ident(vh.proname)
    END fdwhan
FROM pg_catalog.pg_foreign_data_wrapper fdw
    LEFT OUTER JOIN pg_catalog.pg_proc vh on vh.oid=fdwhandler
    LEFT OUTER JOIN pg_catalog.pg_proc vp on vp.oid=fdwvalidator
    LEFT OUTER JOIN pg_catalog.pg_namespace vh_nsp ON vh_nsp.oid=vh.pronamespace
    LEFT OUTER JOIN pg_catalog.pg_namespace vp_nsp ON vp_nsp.oid=vp.pronamespace
    LEFT OUTER JOIN pg_catalog.pg_description des ON (des.objoid=fdw.oid AND des.objsubid=0 AND des.classoid='pg_foreign_data_wrapper'::regclass)
ORDER BY fdwname
SELECT
    CASE
    WHEN (nspname LIKE E'pg\\_temp\\_%') THEN 1
    WHEN (nspname LIKE E'pg\\_%') THEN 0
    ELSE 3 END AS nsptyp,
    nsp.nspname AS name,
    nsp.oid,
    pg_catalog.array_to_string(nsp.nspacl::text[], ', ') as acl,
    r.rolname AS namespaceowner, description,
    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') AS can_create,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = nsp.oid
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = nsp.oid
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = nsp.oid
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = nsp.oid
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=nsp.oid) AS seclabels
FROM
    pg_catalog.pg_namespace nsp
    LEFT OUTER JOIN pg_catalog.pg_description des ON
        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
    LEFT JOIN pg_catalog.pg_roles r ON (r.oid = nsp.nspowner)
WHERE
            nspname NOT LIKE E'pg\\_%' AND
            NOT (
(nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1))
    )
    ORDER BY 1, nspname;
SELECT
    nsp.oid,
    nsp.nspname as name,
    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage
FROM
    pg_catalog.pg_namespace nsp
WHERE
            nspname NOT LIKE 'pg!_%' escape '!' AND
            NOT (
(nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1))
    )

    
ORDER BY nspname;
SELECT
    nsp.nspname as schema_name,
    (nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1)) AS is_catalog,
    CASE
    WHEN nsp.nspname = ANY('{information_schema}')
        THEN false
    ELSE true END AS db_support
FROM
    pg_catalog.pg_namespace nsp
WHERE
    nsp.oid = 2200::OID;
SELECT
    d.oid, d.typname as name, pg_catalog.pg_get_userbyid(d.typowner) as owner,
    bn.nspname as basensp
FROM
    pg_catalog.pg_type d
JOIN
    pg_catalog.pg_type b ON b.oid = d.typbasetype
JOIN
    pg_catalog.pg_namespace bn ON bn.oid=d.typnamespace
WHERE
    d.typnamespace = 2200::oid
ORDER BY
    d.typname;
SELECT
    d.oid, d.typname as name, pg_catalog.pg_get_userbyid(d.typowner) as owner,
    bn.nspname as basensp
FROM
    pg_catalog.pg_type d
JOIN
    pg_catalog.pg_type b ON b.oid = d.typbasetype
JOIN
    pg_catalog.pg_namespace bn ON bn.oid=d.typnamespace
WHERE
    d.typnamespace = 2200::oid
ORDER BY
    d.typname;
SELECT
    CASE
    WHEN (nspname LIKE E'pg\\_temp\\_%') THEN 1
    WHEN (nspname LIKE E'pg\\_%') THEN 0
    ELSE 3 END AS nsptyp,
    nsp.nspname AS name,
    nsp.oid,
    pg_catalog.array_to_string(nsp.nspacl::text[], ', ') as acl,
    r.rolname AS namespaceowner, description,
    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') AS can_create,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = nsp.oid
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = nsp.oid
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = nsp.oid
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = nsp.oid
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_seclabels sl1 WHERE sl1.objoid=nsp.oid) AS seclabels
FROM
    pg_catalog.pg_namespace nsp
    LEFT OUTER JOIN pg_catalog.pg_description des ON
        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
    LEFT JOIN pg_catalog.pg_roles r ON (r.oid = nsp.nspowner)
WHERE
            nspname NOT LIKE E'pg\\_%' AND
            NOT (
(nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1))
    )
    ORDER BY 1, nspname;
SELECT
    2 AS nsptyp,
    nsp.nspname AS name,
    nsp.oid,
    pg_catalog.array_to_string(nsp.nspacl::text[], ', ') as acl,
    r.rolname AS namespaceowner, description,
    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') AS can_create,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'r' AND defaclnamespace = nsp.oid) AS tblacl,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'S' AND defaclnamespace = nsp.oid) AS seqacl,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'f' AND defaclnamespace = nsp.oid) AS funcacl,
    (SELECT pg_catalog.array_to_string(defaclacl::text[], ', ') FROM pg_catalog.pg_default_acl WHERE defaclobjtype = 'T' AND defaclnamespace = nsp.oid) AS typeacl
FROM
    pg_catalog.pg_namespace nsp
    LEFT OUTER JOIN pg_catalog.pg_description des ON
        (des.objoid=nsp.oid AND des.classoid='pg_namespace'::regclass)
    LEFT JOIN pg_catalog.pg_roles r ON (r.oid = nsp.nspowner)
WHERE
        (
(nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1))
    )
ORDER BY 1, nspname;
SELECT
    nsp.oid,
CASE nsp.nspname
    WHEN 'pg_catalog' THEN 'PostgreSQL Catalog (pg_catalog)'
    WHEN 'pgagent' THEN 'pgAgent Job Scheduler (pgagent)'
    WHEN 'information_schema' THEN 'ANSI (information_schema)'
    ELSE nsp.nspname
    END AS name,
    pg_catalog.has_schema_privilege(nsp.oid, 'CREATE') as can_create,
    pg_catalog.has_schema_privilege(nsp.oid, 'USAGE') as has_usage
FROM
    pg_catalog.pg_namespace nsp
WHERE
        (
(nsp.nspname = 'pg_catalog' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pg_class' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'pgagent' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'pga_job' AND
            relnamespace = nsp.oid LIMIT 1)) OR
    (nsp.nspname = 'information_schema' AND EXISTS
        (SELECT 1 FROM pg_catalog.pg_class WHERE relname = 'tables' AND
            relnamespace = nsp.oid LIMIT 1))
    )
ORDER BY 2;
SELECT  sub.oid as oid,
        subname as name,
        subpublications as pub,
        sub.subsynccommit as sync,
        subpublications as cur_pub,
        pga.rolname as subowner,
        subslotname as slot_name,
        subenabled as enabled,
		pg_catalog.SPLIT_PART(pg_catalog.SPLIT_PART(subconninfo,' port',1), '=',2) as host,
		pg_catalog.SPLIT_PART(pg_catalog.SPLIT_PART(subconninfo,'port=',2), ' ',1) as port,
		pg_catalog.SPLIT_PART(pg_catalog.SPLIT_PART(subconninfo,'user=',2), ' ',1) as username,
		pg_catalog.SPLIT_PART(pg_catalog.SPLIT_PART(subconninfo,'dbname=',2), ' ',1) as db,
		pg_catalog.SPLIT_PART(pg_catalog.SPLIT_PART(subconninfo,'connect_timeout=',2), ' ',1) as connect_timeout,
		pg_catalog.SPLIT_PART(pg_catalog.SPLIT_PART(subconninfo,'passfile=',2), ' ',1) as passfile,
		pg_catalog.SPLIT_PART(pg_catalog.SPLIT_PART(subconninfo,'sslmode=',2), ' ',1) as sslmode,
		pg_catalog.SPLIT_PART(pg_catalog.SPLIT_PART(subconninfo,'sslcompression=',2), ' ',1) as sslcompression,
		pg_catalog.SPLIT_PART(pg_catalog.SPLIT_PART(subconninfo,'sslcert=',2), ' ',1) as sslcert,
		pg_catalog.SPLIT_PART(pg_catalog.SPLIT_PART(subconninfo,'sslkey=',2), ' ',1) as sslkey,
		pg_catalog.SPLIT_PART(pg_catalog.SPLIT_PART(subconninfo,'sslrootcert=',2), ' ',1) as sslrootcert,
		pg_catalog.SPLIT_PART(pg_catalog.SPLIT_PART(subconninfo,'sslcrl=',2), ' ',1) as sslcrl
FROM pg_catalog.pg_subscription sub join pg_catalog.pg_roles pga on sub.subowner= pga.oid
WHERE
    sub.subdbid = 16396


SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid = 13442::OID
AND db.datistemplate in (false, False)

ORDER BY datname;
SELECT
    'datacl' AS deftype, COALESCE(gt.rolname, 'PUBLIC') AS grantee,
    g.rolname AS grantor, pg_catalog.array_agg(privilege_type) AS privileges,
    pg_catalog.array_agg(is_grantable) AS grantable
FROM
    (SELECT
        d.grantee, d.grantor, d.is_grantable,
        CASE d.privilege_type
        WHEN 'CONNECT' THEN 'c'
        WHEN 'CREATE' THEN 'C'
        WHEN 'DELETE' THEN 'd'
        WHEN 'EXECUTE' THEN 'X'
        WHEN 'INSERT' THEN 'a'
        WHEN 'REFERENCES' THEN 'x'
        WHEN 'SELECT' THEN 'r'
        WHEN 'TEMPORARY' THEN 'T'
        WHEN 'TRIGGER' THEN 't'
        WHEN 'TRUNCATE' THEN 'D'
        WHEN 'UPDATE' THEN 'w'
        WHEN 'USAGE' THEN 'U'
        ELSE 'UNKNOWN'
        END AS privilege_type
    FROM
        (SELECT
            (d).grantee AS grantee, (d).grantor AS grantor,
            (d).is_grantable AS is_grantable,
            (d).privilege_type AS privilege_type
        FROM
            (SELECT pg_catalog.aclexplode(db.datacl) AS d FROM pg_catalog.pg_database db
            WHERE db.oid = 13442::OID) a
        ) d
    ) d
    LEFT JOIN pg_catalog.pg_roles g ON (d.grantor = g.oid)
    LEFT JOIN pg_catalog.pg_roles gt ON (d.grantee = gt.oid)
GROUP BY g.rolname, gt.rolname;
SELECT
    CASE (a.deftype)
    WHEN 'r' THEN 'deftblacl'
    WHEN 'S' THEN 'defseqacl'
    WHEN 'f' THEN 'deffuncacl'
    WHEN 'T' THEN 'deftypeacl'
    END AS deftype,
    COALESCE(gt.rolname, 'PUBLIC') AS grantee, g.rolname AS grantor, pg_catalog.array_agg(a.privilege_type) as privileges, pg_catalog.array_agg(a.is_grantable) as grantable
FROM
    (SELECT
        (acl).grantee as grantee, (acl).grantor AS grantor, (acl).is_grantable AS is_grantable,
        CASE (acl).privilege_type
        WHEN 'CONNECT' THEN 'c'
        WHEN 'CREATE' THEN 'C'
        WHEN 'DELETE' THEN 'd'
        WHEN 'EXECUTE' THEN 'X'
        WHEN 'INSERT' THEN 'a'
        WHEN 'REFERENCES' THEN 'x'
        WHEN 'SELECT' THEN 'r'
        WHEN 'TEMPORARY' THEN 'T'
        WHEN 'TRIGGER' THEN 't'
        WHEN 'TRUNCATE' THEN 'D'
        WHEN 'UPDATE' THEN 'w'
        WHEN 'USAGE' THEN 'U'
        ELSE 'UNKNOWN'
        END AS privilege_type,
        defaclobjtype as deftype
    FROM
        (SELECT defaclobjtype, pg_catalog.aclexplode(defaclacl) as acl FROM pg_catalog.pg_default_acl dacl
      WHERE dacl.defaclnamespace = 0::OID) d) a
    LEFT JOIN pg_catalog.pg_roles g ON (a.grantor = g.oid)
    LEFT JOIN pg_catalog.pg_roles gt ON (a.grantee = gt.oid)
GROUP BY g.rolname, gt.rolname, a.deftype
ORDER BY a.deftype
SELECT
    rl.*, r.rolname AS user_name, db.datname as db_name
FROM pg_catalog.pg_db_role_setting AS rl
    LEFT JOIN pg_catalog.pg_roles AS r ON rl.setrole = r.oid
    LEFT JOIN pg_catalog.pg_database AS db ON rl.setdatabase = db.oid
WHERE setdatabase = 13442
SELECT
    ts.oid, spcname AS name, spcoptions, pg_catalog.pg_get_userbyid(spcowner) as spcuser,
    pg_catalog.pg_tablespace_location(ts.oid) AS spclocation,
    pg_catalog.array_to_string(spcacl::text[], ', ') as acl,
    pg_catalog.shobj_description(oid, 'pg_tablespace') AS description,
    (SELECT
        pg_catalog.array_agg(provider || '=' || label)
    FROM pg_catalog.pg_shseclabel sl1
    WHERE sl1.objoid=ts.oid) AS seclabels
FROM
    pg_catalog.pg_tablespace ts
ORDER BY name
SELECT
    ts.oid AS oid, spcname AS name, spcowner as owner
FROM
    pg_catalog.pg_tablespace ts
ORDER BY name;
SELECT
	r.oid, r.*, r.rolsuper as rolcatupdate,
	pg_catalog.shobj_description(r.oid, 'pg_authid') AS description,
	ARRAY(
		SELECT
			CASE WHEN am.admin_option THEN '1' ELSE '0' END || rm.rolname
		FROM
			(SELECT * FROM pg_catalog.pg_auth_members WHERE member = r.oid) am
			LEFT JOIN pg_catalog.pg_roles rm ON (rm.oid = am.roleid)
		ORDER BY rm.rolname
	) AS rolmembership,
	(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=r.oid) AS seclabels
	FROM
	pg_catalog.pg_roles r
ORDER BY r.rolcanlogin, r.rolname
SELECT
	r.oid, r.rolname, r.rolcanlogin, r.rolsuper
FROM
	pg_catalog.pg_roles r
ORDER BY r.rolcanlogin, r.rolname
SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid > 13441::OID

AND db.datistemplate in (false, False)

ORDER BY datname;
SET DateStyle=ISO
 SET client_min_messages=notice
 SELECT set_config('bytea_output','hex',false) FROM pg_settings WHERE name = 'bytea_output'
 SET client_encoding='UNICODE';
SELECT version()

SELECT
    db.oid as did, db.datname, db.datallowconn,
    pg_encoding_to_char(db.encoding) AS serverencoding,
    has_database_privilege(db.oid, 'CREATE') as cancreate, datlastsysoid,
    datistemplate
FROM
    pg_catalog.pg_database db
WHERE db.datname = current_database()

        SELECT
            roles.oid as id, roles.rolname as name,
            roles.rolsuper as is_superuser,
            CASE WHEN roles.rolsuper THEN true ELSE roles.rolcreaterole END as
            can_create_role,
            CASE WHEN roles.rolsuper THEN true
            ELSE roles.rolcreatedb END as can_create_db,
            CASE WHEN 'pg_signal_backend'=ANY(ARRAY(
                SELECT pg_catalog.pg_roles.rolname FROM
                pg_catalog.pg_auth_members m JOIN pg_catalog.pg_roles ON
                (m.roleid = pg_catalog.pg_roles.oid) WHERE
                 m.member = roles.oid)) THEN True
            ELSE False END as can_signal_backend
        FROM
            pg_catalog.pg_roles as roles
        WHERE
            rolname = current_user

SELECT
    has_table_privilege(
      'pgagent.pga_job', 'INSERT, SELECT, UPDATE'
    ) has_priviledge
WHERE EXISTS(
    SELECT has_schema_privilege('pgagent', 'USAGE')
    WHERE EXISTS(
        SELECT cl.oid FROM pg_catalog.pg_class cl
        LEFT JOIN pg_catalog.pg_namespace ns ON ns.oid=relnamespace
        WHERE relname='pga_job' AND nspname='pgagent'
    )
)

SELECT
    ts.oid, spcname AS name, spcoptions, pg_catalog.pg_get_userbyid(spcowner) as spcuser,
    pg_catalog.pg_tablespace_location(ts.oid) AS spclocation,
    pg_catalog.array_to_string(spcacl::text[], ', ') as acl,
    pg_catalog.shobj_description(oid, 'pg_tablespace') AS description,
    (SELECT
        pg_catalog.array_agg(provider || '=' || label)
    FROM pg_catalog.pg_shseclabel sl1
    WHERE sl1.objoid=ts.oid) AS seclabels
FROM
    pg_catalog.pg_tablespace ts
ORDER BY name
SELECT
    ts.oid AS oid, spcname AS name, spcowner as owner
FROM
    pg_catalog.pg_tablespace ts
ORDER BY name;
SELECT
	r.oid, r.*, r.rolsuper as rolcatupdate,
	pg_catalog.shobj_description(r.oid, 'pg_authid') AS description,
	ARRAY(
		SELECT
			CASE WHEN am.admin_option THEN '1' ELSE '0' END || rm.rolname
		FROM
			(SELECT * FROM pg_catalog.pg_auth_members WHERE member = r.oid) am
			LEFT JOIN pg_catalog.pg_roles rm ON (rm.oid = am.roleid)
		ORDER BY rm.rolname
	) AS rolmembership,
	(SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=r.oid) AS seclabels
	FROM
	pg_catalog.pg_roles r
ORDER BY r.rolcanlogin, r.rolname
SELECT
	r.oid, r.rolname, r.rolcanlogin, r.rolsuper
FROM
	pg_catalog.pg_roles r
ORDER BY r.rolcanlogin, r.rolname
SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid > 13441::OID

AND db.datistemplate in (false, False)

ORDER BY datname;
SELECT
    db.oid AS did, db.oid, db.datname AS name, db.dattablespace AS spcoid,
    spcname, datallowconn, pg_catalog.pg_encoding_to_char(encoding) AS encoding,
    pg_catalog.pg_get_userbyid(datdba) AS datowner, datcollate, datctype, datconnlimit,
    pg_catalog.has_database_privilege(db.oid, 'CREATE') AS cancreate,
    pg_catalog.current_setting('default_tablespace') AS default_tablespace,
    descr.description AS comments, db.datistemplate AS is_template,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'r' AND defaclnamespace = 0::OID
    ), ', ')) AS tblacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'S' AND defaclnamespace = 0::OID
    ), ', ')) AS seqacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'f' AND defaclnamespace = 0::OID
    ), ', ')) AS funcacl,
        (SELECT pg_catalog.array_to_string(ARRAY(
        SELECT pg_catalog.array_to_string(defaclacl::text[], ', ')
            FROM pg_catalog.pg_default_acl
        WHERE defaclobjtype = 'T' AND defaclnamespace = 0::OID
    ), ', ')) AS typeacl,
    (SELECT pg_catalog.array_agg(provider || '=' || label) FROM pg_catalog.pg_shseclabel sl1 WHERE sl1.objoid=db.oid) AS seclabels,
    pg_catalog.array_to_string(datacl::text[], ', ') AS acl
FROM pg_catalog.pg_database db
    LEFT OUTER JOIN pg_catalog.pg_tablespace ta ON db.dattablespace=ta.OID
    LEFT OUTER JOIN pg_catalog.pg_shdescription descr ON (
        db.oid=descr.objoid AND descr.classoid='pg_database'::regclass
    )
WHERE db.oid > 13441::OID

AND db.datistemplate in (false, False)

ORDER BY datname;
